#include "cpcrslib.h"

int FormatAsmArray(char ** outBuffer, const unsigned char * array, 
	const int rows, const int columns, const char * name, const char * format)
{
	int j,bufcnt = 0;
	size_t length = 0;
	if ( outBuffer != NULL ) 
		length = strlen(*outBuffer);
	// TODO: according to format
	size_t outSize = columns * (5 + 4 * rows) * sizeof(char) + 100 + length;
	fprintf(stderr,"previous length = %ld, outSize = %ld \n", length, outSize );

	*outBuffer = (char*) realloc(*outBuffer,outSize);
	if (*outBuffer == NULL)
	{
		perror(":realloc");
		return 0;
	}
	else fprintf(stderr,"realloc ok\n" );

	const unsigned char * parray = array;

	char *localPointer = *outBuffer + length;
	fprintf(stderr, "localPointer = 0x%p\n", localPointer);

	bufcnt += sprintf(localPointer + bufcnt, "\n._%s\n",name);

	for(int i = 0; i < rows; i++)
	{
		fprintf(stderr, "defb ");
		bufcnt += sprintf(localPointer + bufcnt, "defb ");
		for( j = 0; j < columns - 1; j++)
		{
			fprintf(stderr, format, *(parray + j));
			fprintf(stderr, ",");
			bufcnt += sprintf(localPointer + bufcnt, format, *(parray + j));			
			bufcnt += sprintf(localPointer + bufcnt, ",");
		}
		fprintf(stderr, format, *(parray + j + 1));
		fprintf(stderr, "\n");
		bufcnt += sprintf(localPointer + bufcnt, format, *(parray + j + 1));
		bufcnt += sprintf(localPointer + bufcnt, "\n");
		parray += columns;
	}
	return bufcnt;
}

/**
 * Convert an image to a cpcrslib sprite or tile
 * @param image_wand the magick wand to transform
 * @param outBuffer destination buffer after transformation
 * @param masked if true, generate masked sprite
 * @param mode CPC graphic mode @ref cpc_mode
 * @return size of outBuffer
 */

int cpcrslib(MagickWand *image_wand, char **outBuffer, bool masked)
{

	char *localPointer = malloc(100);
	char * filename = MagickGetImageFilename(image_wand);
	long y;
	size_t columns, rows, nbcolors, ppb;
	nbcolors = MagickGetImageColors(image_wand);
	ppb = nbcolors / 8 ; //TODO
	PixelIterator *iterator;
	PixelWand **pixels;
	register long x;
	int bufcnt = 0;

	unsigned char databyte[ppb];
	unsigned char maskbyte[ppb];
	int j;

	unsigned char palette[nbcolors]; // TODO : remove from here
	memset(palette, 28, nbcolors * sizeof(unsigned char));

	columns = MagickGetImageHeight(image_wand);
	rows = MagickGetImageWidth(image_wand);
	unsigned char *pixelarray = (unsigned char *) malloc (rows * columns / ppb);
	unsigned char *ptrpixelarray = pixelarray;

	fprintf(stderr,"Size %ldx%ld , %ld colors, %ld depth.\n", columns, rows, nbcolors, ppb);


	/*
	 * convert it into a buffer
	 */
	filename = basename(filename);

	iterator = NewPixelIterator(image_wand);
	if (iterator == (PixelIterator *) NULL)
		ThrowWandException(image_wand);
	for (y = 0; y < (long) columns; y++)
	{
		pixels = PixelGetNextIteratorRow(iterator, &rows);
		if (pixels == (PixelWand **) NULL)
			break;
		for (x = 0; x < (long) rows; x++)
		{
			// could it be replace by modulo
			for (j = 0; j < ppb; j++)
			{
				if (masked)
				{
					if (PixelGetAlpha(pixels[x + j]))
						maskbyte[j] = 0x00;
					else
						maskbyte[j] = 0xFF;
				}
				databyte[j] = palettise(pixel2cpc(pixels[x + j]), palette,
						nbcolors);
			}
			if (masked)
			{
				*(ptrpixelarray++) = cpc2displaypixeldata(maskbyte, ppb);
			}
			*(ptrpixelarray++) = cpc2displaypixeldata(databyte, ppb);
			// verify with ppb != 2
			x += ppb - 1;
		}
	}

	if (y < (long) columns)
		ThrowWandException(image_wand);
	iterator = DestroyPixelIterator(iterator);
	image_wand = DestroyMagickWand(image_wand);
	MagickWandTerminus();

	bufcnt += sprintf(localPointer + bufcnt, "/*\t\tGenerated by Magick2CPC : DO NOT EDIT.\t\t*/\n");
	bufcnt += sprintf(localPointer + bufcnt, "\n#asm\n");
	bufcnt += FormatAsmArray(&localPointer, pixelarray, rows / ppb , columns , filename, "$%2.2X");
	bufcnt += FormatAsmArray(&localPointer, palette, 1, nbcolors, "tintas", "%d" );
	bufcnt += sprintf(localPointer + bufcnt, "#endasm\n");

	*outBuffer = localPointer;
	fprintf(stderr, "localPointer = 0x%p\n", localPointer);
	return bufcnt;
}

